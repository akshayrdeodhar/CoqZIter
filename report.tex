\newtheorem{theorem}{Lemma}

\hypertarget{motivation}{%
\section{Motivation}\label{motivation}}

Plasticine \cite{plasticine} is a coarse-grained reconfigurable
architecture for deep learning training and inference workloads. The
architecture consists of a grid of Pattern Compute Units (PCUs) and
Pattern Memory Units (PMUs) connected by an on-chip programmable
switching fabric. Off-chip memory access is carried out using Address
Generator and Coalescing Units (AGCUs).The hardware can be programmed
using a \emph{template DSL}. Address calculations in the PMU and AGCU
are done using a reconfigurable scalar datapath.\cite{plasticine} Loop
induction variables are programmed using a set of configurable counter
chains, where counter start, step and bound can be configured. The
number of stages on the datapath are limited. Multidimensional tensor
accesses and software-defined banking (where a single large tensor is
partitioned over multiple PMUs) lead to complicated address or control
expressions for which the available stages are insufficient. Handling
this requires the use of an extra PMU purely for address calculations.
The DSL compiler, therefore has a set of arithmetic rewrite rules which
replace address expressions with simpler expressions that use less
operations or datapath stages. Rewrite rules are also used for
supporting operations such as \(/\) or \(\%\), which are not supported
in the hardware, but can be transformed into \(>>\) or \(\&\) in special
cases. These rules are not standard mathematical identities- they check
certain constraints on the values involved in the expression based on
information that is statically known. These rules, thus, are theorems of
the form

\begin{theorem}
    If a set of constraints $C$ on $expr1$ is satisified, then $ expr_1 = expr_2 $
\end{theorem}

However, they are not formally proven before addition to the compiler.
An incorrect rewrite rule might, in some specific case, replace an
expression with another which is not equivalent to the original.

Complex array access expressions also occur in general nested loop
programs. Previous work\cite{strength} has investigated strength
reduction for optimizing complicated array index expressions. If loop
bounds are known at compile time, the same rewrite rules can be applied
to general nested loop programs.

This project aimed to achieve the following goals.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Evaluate the feasibility of using a theorem prover for proving
  arithmetic expression rewrite rules.
\item
  Write checked proofs, or disprove a set of rules, adding stronger
  preconditions to correct the incorrect rules.
\item
  Create a set of lemmas or a methodology for developing proofs for new
  rules.
\end{enumerate}

\hypertarget{problem-statement}{%
\section{Problem Statement}\label{problem-statement}}

Specifically, we may state our problem as:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Evaluate the feasibility of using the \textbf{Coq} proof assistant for
  proving arithmetic expression rewrite rules designed for reducing
  reconfigurable scalar datapath stages by eliminating arithmetic
  operations, or replacing them with simpler operations.
\item
  Prove and disprove theorems of the following forms, on
  \textbf{integers}.

  \begin{itemize}
  \tightlist
  \item
    The value of an expression
    \(e \in [L({subexpression\_bounds}), R({subexpression\_bounds})]\),
    where \({subexpression\_bounds}\) is the set of conservative bounds
    for the subexpressions of \(e\), where \(e\) is of the form
    \(e = e1 op e2\).
  \item
    If \(e = f(e_1, e_2, .. e_{n_1})\) and conditions
    \(C_1, C_2, C_3, .. C_m\) hold, then
    \(e = f'(e_1', e_2', ... e_{n_2}')\). (that is, \(f\) can be safely
    replaced with \(f'\) in the program. Note that the reverse
    transformation may not always be correct).\footnote{We shall refer
      to \(f\) as the \emph{original expression} and \(f'\) as the
      \emph{replacement expression}.}
  \end{itemize}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Enable (TODO: new theorem proofs) by:

  \begin{itemize}
  \tightlist
  \item
    Define primitives for expressing intervals and iterators.
  \item
    Lay the foundation for a Coq library of results about bounds and
    transformations.
  \item
    Extracting results repeatedly used in Coq proofs as independent
    Lemmas.
  \item
    Document proof and tactic usage patterns that commonly occur in
    proofs of the above two kinds.
  \end{itemize}
\end{enumerate}

\#\#z

The rewrite rules that we set out to prove will give significant
performance improvements in standard CPU-based loop nests. In a sense,
they are analogous to strength reduction, or induction variable
elimination. The rules that we select are different from these
optimizations due to the following factors-

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Unlike strength reduction, which merely reduces expensive arithmetic
  operations in a loop nest, these are built to be applied in a
  reconfigurable scalar datapath with a limited number of stages, with
  some operations being \emph{unavailable}. In some cases, such
  transformations are necessary for a buffer to \emph{fit} within a
  given number of memory units, while in others, they eliminate
  operations which are incomputable on the hardware.
\item
  Because the workloads being compiled have long runtimes, this is a
  situation where a longer compile time can be traded off for better
  performance at runtime.\footnote{Note that Coq itself \emph{does not
    execute} at compile time. The compile time overhead is due to the
    fact that the compiler will carry out a dataflow-style bounds
    analysis pass for establishing the intervals within which values of
    variables lie, and carry out multiple precondition checks before
    replacing an arithmetic expression with another (cheaper)
    expression.}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  These rules are primarily concerned with \emph{iterators},
  \emph{intervals}, and the \emph{division} and \emph{modulo} arithmetic
  operations.
\end{enumerate}

\hypertarget{solution-overview}{%
\section{Solution Overview}\label{solution-overview}}

We start with proposing a set of theorems that can serve as a basis for
analysis and transformations by the compiler once proven correct. These
are provided in \autoref{theorems}.

As address expressions calculate byte offsets, and iterators take
integer values, all of our transformations can be expressed as theorems
on Integers. Hence, we utilize the \texttt{Zarith} module of the Coq
Standard Library which defines the abstract binary integer type
\texttt{Z}, operations on \texttt{Z}, and further contains a rich set of
useful lemmas.

We define our \textbf{Iterator} in terms of its \emph{start},
\emph{end}, and \emph{step} values over \texttt{Z}. The definition is
meant to characterize the \emph{set of integer values that the iterator
may take}, and can be used to represent a loop iterator of the form
\VERB|\KeywordTok{FOR}\NormalTok{ I }\KeywordTok{=}\NormalTok{ \_START, \_END, \_STEP}|
or a hardware counter of the form
\VERB|\NormalTok{(\_START until \_END by \_STEP)}|.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{Inductive Iterator :}\NormalTok{ Type }\OperatorTok{:=}
    \OperatorTok{|}\NormalTok{ iterator }\OperatorTok{(}\NormalTok{\_start \_end \_step }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{)}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

However, we don't wish to reason about the iterator itself, but the
\emph{values} that an iterator might take. So we define what it means
for a value to \emph{belong} to an iterator, as follows.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Definition inIterator }\OperatorTok{(}\NormalTok{x }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{)} \OperatorTok{(}\NormalTok{I }\OperatorTok{:}\NormalTok{ Iterator}\OperatorTok{)} \OperatorTok{:=}
\NormalTok{    match I with }
    \OperatorTok{|}\NormalTok{ iterator \_start \_end \_step }\OperatorTok{=\textgreater{}} 
\NormalTok{        match \_step with}
        \OperatorTok{|}\NormalTok{ Z0 }\OperatorTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{=}\NormalTok{ \_start }
        \OperatorTok{|}\NormalTok{ Zpos \_ }\OperatorTok{=\textgreater{}} \OperatorTok{(}\NormalTok{\_start }\OperatorTok{\textless{}=}\NormalTok{ x }\OperatorTok{/}\NormalTok{\textbackslash{} x }\OperatorTok{\textless{}=}\NormalTok{ \_end}\OperatorTok{)} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{\_step }\OperatorTok{|} \OperatorTok{(}\NormalTok{x }\OperatorTok{{-}}\NormalTok{ \_start}\OperatorTok{))}
        \OperatorTok{|}\NormalTok{ Zneg \_ }\OperatorTok{=\textgreater{}} \OperatorTok{(}\NormalTok{\_end }\OperatorTok{\textless{}=}\NormalTok{ x }\OperatorTok{/}\NormalTok{\textbackslash{} x }\OperatorTok{\textless{}=}\NormalTok{ \_start}\OperatorTok{)} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{\_step }\OperatorTok{|} \OperatorTok{(}\NormalTok{\_start }\OperatorTok{{-}}\NormalTok{ x}\OperatorTok{))}
        \KeywordTok{end}
    \KeywordTok{end}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

Notice the two conditions: the value must lie between the iterator
bounds, and must be obtained by adding an integer multiple of
\texttt{\_step} to \texttt{\_start}. We also define trivial getters to
extract the value of \texttt{\_start}, \texttt{\_end}, \texttt{\_step},
\texttt{min}, or \texttt{max} of an iterator. For example, the following
function extracts the minimum value an iterator may take:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Definition iteratorMin }\OperatorTok{(}\NormalTok{I }\OperatorTok{:}\NormalTok{ Iterator}\OperatorTok{)} \OperatorTok{:}\NormalTok{ Z }\OperatorTok{:=}
\NormalTok{match I with}
\OperatorTok{|}\NormalTok{ iterator \_start \_end \_step }\OperatorTok{=\textgreater{}} 
\NormalTok{        match \_step with }
        \OperatorTok{|}\NormalTok{ Zneg \_ }\OperatorTok{=\textgreater{}}\NormalTok{ \_end}
        \OperatorTok{|}\NormalTok{ \_ }\OperatorTok{=\textgreater{}}\NormalTok{ \_start}
        \KeywordTok{end}
    \KeywordTok{end}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

Similarly, we define our \textbf{Interval} in terms of its \emph{start}
and \emph{end} values over \texttt{Z}. The definition is meant to
characterize the bounds within which the value of an expression will
lie.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{Inductive Interval :}\NormalTok{ Type }\OperatorTok{:=}
    \OperatorTok{|}\NormalTok{ interval }\OperatorTok{(}\NormalTok{\_start \_end }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{)}\NormalTok{.}

\NormalTok{Definition inInterval }\OperatorTok{(}\NormalTok{x}\OperatorTok{:}\NormalTok{ Z}\OperatorTok{)} \OperatorTok{(}\NormalTok{I}\OperatorTok{:}\NormalTok{ Interval}\OperatorTok{)} \OperatorTok{:=}
\NormalTok{    match I with}
\NormalTok{    interval \_start \_end }\OperatorTok{=\textgreater{}}\NormalTok{ \_start }\OperatorTok{\textless{}=}\NormalTok{ x }\OperatorTok{\textless{}=}\NormalTok{ \_end}
    \KeywordTok{end}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

For a strength reduction or the use of a \emph{parallel counter
chain}\footnote{B is a counter chain parallel to A if it executes in
  lock-step with A, and terminates when A terminates. Note that this is
  similar to \emph{strength reduction} with an auxiliary variable being
  updated every loop iteration.}, we need to to ensure that the
\emph{replacement expression} takes the same value as the \emph{original
expression} for every step of the iterator. Hence, we define the
following function to get the value of an iterator in its \(k^{th}\)
iteration\footnote{Note that our \(k\) is zero-indexed.}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Definition kthIterVal }\OperatorTok{(}\NormalTok{k }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{)} \OperatorTok{(}\NormalTok{I }\OperatorTok{:}\NormalTok{ Iterator}\OperatorTok{)} \OperatorTok{:=}
  \OperatorTok{(}\NormalTok{iteratorStart I}\OperatorTok{)} \OperatorTok{+}\NormalTok{ k * }\OperatorTok{(}\NormalTok{iteratorStep I}\OperatorTok{)}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

Now, we can formally define theorems for useful transformations in Coq.
Below is a formalization of the following \emph{Iterator Replacement}
transformation:

If \((c | step) \wedge x \in I(start, end, step)\), then

\begin{itemize}
\tightlist
\item
  \(x / c \in I(start/c, end/c, step/c)\)
\item
  \(\forall k \in Z, k^{th}Iter ~k~ I(start/c, end/c, step/c) = k^{th}Iter ~k~ I(start, end, step)\)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{Theorem div\_of\_iter :}\NormalTok{ forall x c }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{,}\NormalTok{ forall I }\OperatorTok{:}\NormalTok{ Iterator}\OperatorTok{,}
    \OperatorTok{(}\NormalTok{c }\OperatorTok{\textless{}\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{c }\OperatorTok{|} \OperatorTok{(}\NormalTok{iteratorStep I}\OperatorTok{))} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{inIterator x I}\OperatorTok{)} \OperatorTok{{-}\textgreater{}} 
    \OperatorTok{(}\NormalTok{inIterator }\OperatorTok{(}\NormalTok{x }\OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
        \OperatorTok{(}\NormalTok{iterator }\OperatorTok{((}\NormalTok{iteratorStart I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
                  \OperatorTok{((}\NormalTok{iteratorEnd I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
                  \OperatorTok{((}\NormalTok{iteratorStep I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)))}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{Theorem div\_of\_iter\_kth\_val :}\NormalTok{ forall x c k }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{,}\NormalTok{ forall I }\OperatorTok{:}\NormalTok{ Iterator}\OperatorTok{,}
    \OperatorTok{(}\NormalTok{c }\OperatorTok{\textless{}\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{c }\OperatorTok{|} \OperatorTok{(}\NormalTok{iteratorStep I}\OperatorTok{))} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{inIterator x I}\OperatorTok{)} \OperatorTok{{-}\textgreater{}} 
    \OperatorTok{(}\NormalTok{kthIterVal k I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c }\OperatorTok{=}\NormalTok{ kthIterVal k }
        \OperatorTok{(}\NormalTok{iterator }\OperatorTok{((}\NormalTok{iteratorStart I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
                  \OperatorTok{((}\NormalTok{iteratorEnd I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
                  \OperatorTok{((}\NormalTok{iteratorStep I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{))}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

The proof of these theorems implies the legality of the following
transformation\footnote{Note that these theorems are stating facts about
  integers and hence any transformations they enable are platform
  agnostic.}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\NormalTok{x }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{10000}\OperatorTok{;}\NormalTok{ x }\OperatorTok{+=} \DecValTok{6}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{...}
\NormalTok{    y }\OperatorTok{=}\NormalTok{ x}\OperatorTok{/}\DecValTok{3}\OperatorTok{;}
\NormalTok{    foo}\OperatorTok{(}\NormalTok{y}\OperatorTok{);}
    \OperatorTok{...}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now, the compiler can match \(x \in iterator(2, 100, 6)\) and \(c = 3\)
to generate the following transformed code eliminating a division
operation in lieu of an addition in every iteration. If a code similar
to this were running on a reconfigurable scalar datapath, we would
eliminating a division stage in exchange for a parallel counter.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\NormalTok{x }\OperatorTok{=} \DecValTok{2}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{10000}\OperatorTok{;}\NormalTok{ x }\OperatorTok{+=} \DecValTok{6}\OperatorTok{,}\NormalTok{ y }\OperatorTok{+=} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{...}
\NormalTok{    foo}\OperatorTok{(}\NormalTok{y}\OperatorTok{);}
    \OperatorTok{...}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We then prove our set of theorems in Coq. For example, here is the proof
of \VERB|\NormalTok{Theorem div\_of\_iter\_kth\_val}|. Some of our
interesting \texttt{Theorems} and their proofs can be found in
\autoref{proofs}. The rest are available on
\href{https://gitfront.io/r/user-8813495/NSEjGqe31hHN/cs6245proj/}{github}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Proof.}
\NormalTok{    intros. destruct H as }\OperatorTok{[}\NormalTok{H0 }\OperatorTok{[}\NormalTok{H1 H2}\OperatorTok{]]}\NormalTok{.}
\NormalTok{    destruct I. unfold iteratorStep in H1.}
\NormalTok{    unfold iteratorStart. unfold iteratorEnd. unfold iteratorStep.}
\NormalTok{    destruct H1 as }\OperatorTok{[}\NormalTok{step\_by\_c H1}\OperatorTok{]}\NormalTok{.}
\NormalTok{    unfold inIterator in H2.}
\NormalTok{    unfold kthIterVal. unfold iteratorStart. unfold iteratorStep.}
\NormalTok{    rewrite H1. rewrite Z.mul\_assoc. }
\NormalTok{    rewrite Z\_div\_plus\_full. }\DecValTok{2}\OperatorTok{:}\NormalTok{ assumption.}
\NormalTok{    rewrite Z\_div\_mult\_full. }\DecValTok{2}\OperatorTok{:}\NormalTok{ assumption.}
\NormalTok{    reflexivity.}
\NormalTok{Qed.}
\end{Highlighting}
\end{Shaded}

During the course of our project, we observed some recurring patterns
while using Coq to formalize our proofs which made our lives easier. We
believe that the following strategies will be useful for proofs of a
similar nature.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  While simpler lemmas can be proven by repeated use of
  \texttt{destruct} and \texttt{unfold} (making the granularity of
  abstraction finer and finer) upon which the goals become easily
  apparent. For more involved proofs, however, a ``guided'' approach is
  necessary. It is better to create a proof sketch by hand, identify
  intermediate ``goals'' which make sense \emph{intuitively}. Then, one
  can use lemmas from Coq libraries to reach these intermediate goals
  by:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Breaking down existing Coq goals.
  \item
    Reducing available hypotheses.
  \item
    Alternatively, simply \texttt{assert} the intermediate goal that you
    seek to prove, to add it to the Coq goals. Then prove it like a
    normal goal, upon which it gets added to the hypotheses set.
  \end{enumerate}
\item
  There will be junctures where goals are reduced to arithmetic
  identities or results which intuitively make sense. It can however be
  cumbersome to track down a sequence of theorems to apply to prove
  these. Such goals usually are trivially proven by one of the following
  tactics:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    \texttt{ring}: For solving \emph{equations} involving \emph{ring}
    arithmetic operations. (+, -, \(\times\)).
  \item
    \texttt{nia}: For solving \emph{inequations}, trivially does
    manipulations on both sides of an inequality.
  \item
    \texttt{remember}: For substituting a variable in place of a
    subexpression. (eg. Define a new \(p\) as \(p = z \times z'\) for a
    given \(z\) and \(z'\).
  \end{enumerate}
\item
  At some junctures, it seems that a particular Lemma from a library
  \emph{is} applicable, but Coq is unable to match it with existing
  hypotheses. Here, one can \emph{explicitly} specify which
  subexpressions Coq should try to match the lemma with. For example,
  the lemma \texttt{Z\_div\_le} makes a statement about 3 integers
  \texttt{a,\ b,\ c}. One can match a particular subexpression
  \texttt{e} as \texttt{c} by invoking
  \texttt{apply\ (@Z\_div\_le\ \_\ \_\ e)}.
\item
  Use \texttt{destruct} judiciously. The \texttt{destruct} tactic breaks
  down conjunctions and disjunctions, expands inductive type
  definitions, or applies a hypothesis to all applicable cases and
  destroys it.

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Expanding type definitions in the correct order will result in
    smaller subgoals, and a succinct proof. Improper orders land you in
    limbo.
  \item
    Be careful when destroying hypotheses! You might need them at a
    later point!
  \end{enumerate}
\item
  Use \texttt{induction} judiciously. While one can try to
  \emph{brute-force} a proof by cases by going down the rabbit hole of
  induction over all variables. This will mean reinventing the wheel,
  and will result in an explosion of subgoals, which can become tedious
  to keep track of. Proofs can be done succinctly and intuitively by
  using existing high-level theorems instead.
\item
  Intuitive non-trivial results are hard to find in the Coq library
  documents. Another approach here is to download the Coq source, and
  grep\footnote{search} the results and the comments directly.
  Thankfully, lemmas in the \texttt{ZArith} module are peppered with
  useful comments, making this feasible.
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Intuitions about integers \emph{can} be wrong, and that becomes
  apparent when you try to prove your ``intuitive'' facts using theorems
  from \texttt{ZArith}.
\item
  The following libraries provide useful results that we used in our
  proofs:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    BinInt: results about arithmetic operations, identities, sundry
    arithmetic lemmas.
  \item
    Zorder: operations on both sides of \(\le\), \(\ge\), \(<\), \(>\).
  \item
    Znumbertheory: results about divisibility, gcd, modulo.
  \item
    Zdiv: results about integer division. (The \emph{division folding}
    theorem that we set out to prove was an existing lemma in
    \texttt{Zdiv}).
  \item
    ZArith.Zarith (for \texttt{ring}).
  \item
    Coq.micromega.Lia (for \texttt{nia}).
  \end{enumerate}
\end{enumerate}

\hypertarget{usage}{%
\section{Usage}\label{usage}}

This project aims to prevent the addtion of incorrect arithmetic rewrite
rules (\textasciitilde peephole optimizations) to a compiler. The rules
being considered are \emph{general}, and only require compile time
\emph{precondition} checks, rather than brute-force enumeration of all
possible values. An incorrect rule might replace some original program
expression with a \emph{replacement expression} which takes a different
value for some corner case value of inputs. A developer might debug such
a compiler bug by enumerating all values of the iterators involved in
the corner case for which the rule fails, and fixing that specific
corner case. Such ad-hoc fixes will not guarantee the correctness of the
rule since the addition of new preconditions will end up fixing only the
\emph{specific instance} where it fails, and there might be many more
such ``corner cases''. What we truly want is to implement a general
rule.

We show that such rules can be proved as theorems about numbers
\emph{before} a developer adds them to the compiler. With a Coq-checked
proof, we have a guarantee that the rule will hold, and the
transformation will be correct as long as its preconditions are
satisfied. Such general rules only require a few precondition checks at
compile time, as opposed to transformations checked by compile-time
enumeration by a solver such as Z3.

The previous section demonstrates the usage of one Coq-checked rewrite
rule by the compiler. Simple usage illustrations for other
theorems/rules can be found in \autoref{theorems}.

We envision the usage of our idea by a compiler developer in the
following workflow.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The developer finds a recurring expression pattern, and concocts a way
  to replace it with a cheaper expression.
\item
  They express this optimization as a transformation rule with
  preconditions, and formalize it as a theorem of the form
  \(precondition \implies e_{original} = e_{replacement}\) in Coq.
\item
  They attempt to prove the theorem using Coq standard library theorems,
  and lemmas that they have previously proven (somewhat like the library
  that we have developed).

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    If the proof is successful, the rule may safely be implemented as a
    transformation in the compiler.
  \item
    If the proof leads to a contradiction, they repair their
    transformation by adding a stronger precondition.
  \end{enumerate}
\item
  If the proof does not \emph{terminate}, there is no guarantee about
  its correctness. The developer might still choose to implement the the
  transformation, (for example, in cases where it is necessary for
  making a kernel work on a particular hardware platform), \emph{with
  the knowledge that it might be incorrect}. If the developer encounters
  a corner case bug, they may choose to incorporate its fix into the
  theorem preconditions, and attempt to prove the rule again.
\end{enumerate}

We hope that this demonstration encourages the development of such Coq
modules for different kinds of transformations.

\begin{verbatim}
1. demonstration of the practicality of your approach through a prototype implementation in a compiler framework or through performance studies of handcoded examples, and 

2. a comparison with related work.
\end{verbatim}

\hypertarget{theorems}{%
\section{Appendix A: Theorems, and their applications}\label{theorems}}

\hypertarget{sundry-transformations}{%
\subsection{Sundry Transformations}\label{sundry-transformations}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Division Folding

  \begin{itemize}
  \tightlist
  \item
    If \(x \in \mathbb{Z} \wedge a > 0 \wedge b > 0\)

    \begin{itemize}
    \tightlist
    \item
      \((x / a) / b = x / (a * b)\)
    \end{itemize}
  \item
    Example: Scratchpad-match calculations might lead to multiple
    division operations on an address offset. An expression of the form
    \((x / 1024) / 4\) may be transformed to \(x / (1024 * 4)\), which
    can be folded to \((x / 4096)\), saving a division operation.
  \end{itemize}
\end{enumerate}

\hypertarget{bounds}{%
\subsection{Bounds}\label{bounds}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bounds Computation

  \begin{itemize}
  \item
    If \(x \in [a, b] \wedge y \in [c, d]\), then

    \begin{itemize}
    \tightlist
    \item
      \(x + y \in [a + c, b + d]\)
    \item
      \(x - y \in [a - d, b - c]\)
    \end{itemize}
  \item
    Example:

\begin{Shaded}
\begin{Highlighting}[]
  \ControlFlowTok{for} \OperatorTok{(}\NormalTok{i }\OperatorTok{=} \DecValTok{205}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{250}\OperatorTok{;}\NormalTok{ i }\OperatorTok{+=} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{j }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}=} \DecValTok{30}\OperatorTok{;}\NormalTok{ j }\OperatorTok{+=} \DecValTok{4}\OperatorTok{)} \OperatorTok{\{}
      \OperatorTok{...}
\NormalTok{      x }\OperatorTok{=}\NormalTok{ input}\OperatorTok{();}
      \OperatorTok{...}
\NormalTok{      a }\OperatorTok{=} \OperatorTok{(}\NormalTok{j }\OperatorTok{{-}}\NormalTok{ x }\OperatorTok{\%} \DecValTok{8} \OperatorTok{+} \DecValTok{200}\OperatorTok{)} \OperatorTok{+}\NormalTok{ i}\OperatorTok{;}
\NormalTok{      index }\OperatorTok{=}\NormalTok{ a }\OperatorTok{/} \DecValTok{100}\OperatorTok{;}
\NormalTok{      offset }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\%} \DecValTok{100}\OperatorTok{;}
      \OperatorTok{...}
    \OperatorTok{\}}
  \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

    The bounds of \(i\) and \(j\) are known at compile time:
    \(i \in [205, 250]\), \(j \in [2, 30]\). Conservative bounds for
    \(x \% 8\) are also known to be \([0, 7]\). Thus,
    \(j - x \% 8 \in [-2, 30]\), \(j - x \% 8 + 200 \in [198, 230]\),
    and \(a \in [403, 480]\).
  \end{itemize}
\item
  Expression Reduction using bounds

  \begin{itemize}
  \tightlist
  \item
    If \(x \in [a, b] \wedge (a/c = b/c)\) then

    \begin{itemize}
    \tightlist
    \item
      \(x / c = a/c\)
    \item
      \(x \% c = a \% c + (x - a)\)
    \end{itemize}
  \item
    Example: Continuing with the example above, since
    \(a \in [403, 480]\), the compiler can replace \(a/100\) with \(4\)
    and \(a \% 100\) with \(3 + (x - 403)\). Depending on the rest of
    the program, the computation of \(a\) might turn out to be dead code
    now, providing even further optimization opportunities.
  \end{itemize}
\end{enumerate}

\hypertarget{iterators}{%
\subsection{Iterators}\label{iterators}}

\begin{itemize}
\tightlist
\item
  Let \(I\) be an iterator \((start, end, step)\)
\item
  \(x \in I\) if \((start <= x <= end) \wedge (step | (x - start))\)
\item
  \(k^{th}Iter : (k : Z) (I : (start, end, step)) \to Z := start + k\times step\)
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Modulo Simplification

  \begin{itemize}
  \tightlist
  \item
    If \(x \in I(start, end, step)\)

    \begin{itemize}
    \tightlist
    \item
      \((c | step) \implies x \% c = start \% c\)
    \end{itemize}
  \end{itemize}
\item
  Iterator Replacement

  \begin{itemize}
  \tightlist
  \item
    If \(x \in I(start, end, step)\)

    \begin{itemize}
    \tightlist
    \item
      \(x + c \in\) I(start + c, end + c, step)
    \item
      \(\forall k \in Z, k^{th}Iter ~k~ I(start + c, end + c, step) = k^{th}Iter ~k~ I(start, end, step)\)
    \end{itemize}
  \item
    If \((c | step) \wedge x \in I(start, end, step)\)

    \begin{itemize}
    \tightlist
    \item
      \(x / c \in I(start/c, end/c, step/c)\)
    \item
      \(\forall k \in Z, k^{th}Iter ~k~ I(start/c, end/c, step/c) = k^{th}Iter ~k~ I(start, end, step)\)
    \end{itemize}
  \end{itemize}
\end{enumerate}

\begin{itemize}
\item
  Example:

\begin{Shaded}
\begin{Highlighting}[]
  \ControlFlowTok{for} \OperatorTok{(}\NormalTok{i }\OperatorTok{=} \DecValTok{64}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{256}\OperatorTok{;}\NormalTok{ i}\OperatorTok{+=} \DecValTok{16}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    bank }\OperatorTok{=} \OperatorTok{(}\NormalTok{i }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{\%} \DecValTok{8}\OperatorTok{;}
  \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  In this example, \(i \in I(64, 256, 16)\), with \emph{iterator
  replacement}, the compiler concludes that
  \((i+1) \in I(65, 257, 16)\). Since \((8 | 16)\),
  \((i + 1) \% 8 = 65 \% 8 = 1\) by \emph{modulo simplification}. Since
  \texttt{bank} is a loop independent constant, it can be propagated out
  of the loop.
\end{itemize}

\hypertarget{proofs}{%
\section{Appendix B: Selected Proofs}\label{proofs}}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{Theorem div\_of\_iter :}\NormalTok{ forall x c }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{,}\NormalTok{ forall I }\OperatorTok{:}\NormalTok{ Iterator}\OperatorTok{,}
    \OperatorTok{(}\NormalTok{c }\OperatorTok{\textless{}\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{c }\OperatorTok{|} \OperatorTok{(}\NormalTok{iteratorStep I}\OperatorTok{))} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{(}\NormalTok{inIterator x I}\OperatorTok{)} \OperatorTok{{-}\textgreater{}} 
    \OperatorTok{(}\NormalTok{inIterator }\OperatorTok{(}\NormalTok{x }\OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
        \OperatorTok{(}\NormalTok{iterator }\OperatorTok{((}\NormalTok{iteratorStart I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
                  \OperatorTok{((}\NormalTok{iteratorEnd I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
                  \OperatorTok{((}\NormalTok{iteratorStep I}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)))}\NormalTok{.}
\NormalTok{Proof.}
\NormalTok{    intros. destruct H as }\OperatorTok{[}\NormalTok{H0 }\OperatorTok{[}\NormalTok{H1 H2}\OperatorTok{]]}\NormalTok{. destruct I. }
\NormalTok{    unfold iteratorStep in H1. }
\NormalTok{    unfold iteratorStart. unfold iteratorEnd. unfold iteratorStep.}
    \OperatorTok{(}\NormalTok{* common steps taken out *}\OperatorTok{)}
\NormalTok{    destruct H1 as }\OperatorTok{[}\NormalTok{step\_by\_c H1}\OperatorTok{]}\NormalTok{.}
\NormalTok{    rewrite H1.}
    \OperatorTok{(}\NormalTok{* rewrite using lemma instead of trying to apply the lemma *}\OperatorTok{)}
\NormalTok{    rewrite Z\_div\_mult\_full.}
    \OperatorTok{(}\NormalTok{* prove the second goal first as it is easy *}\OperatorTok{)}
    \DecValTok{2}\OperatorTok{:}\NormalTok{ assumption.}
    \OperatorTok{(}\NormalTok{* go on as usual *}\OperatorTok{)}
\NormalTok{    unfold inIterator in H2. }
\NormalTok{    unfold inIterator.}
\NormalTok{    induction \_step as }\OperatorTok{[} \OperatorTok{|}\NormalTok{ step }\OperatorTok{|}\NormalTok{ step }\OperatorTok{]}\NormalTok{.}
    \OperatorTok{(}\NormalTok{* easy when step is }\DecValTok{0}\NormalTok{ *}\OperatorTok{)}
    \OperatorTok{{-}}\NormalTok{ assert }\OperatorTok{(}\NormalTok{step\_by\_c }\OperatorTok{=} \DecValTok{0}\OperatorTok{)}\NormalTok{ as H4. nia.}
\NormalTok{      rewrite H4. rewrite H2. simpl. reflexivity.}
    \OperatorTok{(}\NormalTok{* now step is positive *}\OperatorTok{)}
    \OperatorTok{{-}}\NormalTok{ destruct H2 as }\OperatorTok{[[}\NormalTok{H21 H22}\OperatorTok{]}\NormalTok{ H23}\OperatorTok{]}\NormalTok{.}
\NormalTok{      destruct H23 as }\OperatorTok{[}\NormalTok{x\_minus\_start\_by\_step H23}\OperatorTok{]}\NormalTok{.}
\NormalTok{      rewrite H1 in H23.}
      \OperatorTok{(}\NormalTok{* Intermediate lemma *}\OperatorTok{)}
\NormalTok{      assert }\OperatorTok{(}\NormalTok{x }\OperatorTok{=}\NormalTok{ \_start }\OperatorTok{+}\NormalTok{ x\_minus\_start\_by\_step * step\_by\_c * c}\OperatorTok{)} 
\NormalTok{        as H4 by nia.}
\NormalTok{      assert }\OperatorTok{(}\NormalTok{x }\OperatorTok{/}\NormalTok{ c }\OperatorTok{=}\NormalTok{ \_start }\OperatorTok{/}\NormalTok{ c }\OperatorTok{+}\NormalTok{ x\_minus\_start\_by\_step * step\_by\_c}\OperatorTok{)}
\NormalTok{        as H5.}
\NormalTok{        rewrite H4. apply Z\_div\_plus\_full. assumption.}
      \OperatorTok{(}\NormalTok{* induction directly on step\_by\_c *}\OperatorTok{)}
\NormalTok{      induction step\_by\_c as }\OperatorTok{[} \OperatorTok{|}\NormalTok{ step\_by\_c }\OperatorTok{|}\NormalTok{ step\_by\_c }\OperatorTok{]}\NormalTok{.}
      \OperatorTok{(}\NormalTok{* step by c }\OperatorTok{=} \DecValTok{0}\NormalTok{ is invalid since step is positive *}\OperatorTok{)}
      \OperatorTok{+}\NormalTok{ discriminate.}
      \OperatorTok{(}\NormalTok{* step by c is positive *}\OperatorTok{)}
      \OperatorTok{+} \KeywordTok{repeat}\NormalTok{ split.}
        \OperatorTok{(}\NormalTok{* lower bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ apply Z\_div\_le. nia. assumption.}
        \OperatorTok{(}\NormalTok{* upper bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ apply Z\_div\_le. nia. assumption.}
        \OperatorTok{(}\NormalTok{* divisibility *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ exists x\_minus\_start\_by\_step. rewrite H5. ring.}
      \OperatorTok{(}\NormalTok{* step by c is negative *}\OperatorTok{)}
      \OperatorTok{+} \KeywordTok{repeat}\NormalTok{ split.}
        \OperatorTok{(}\NormalTok{* lower bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ assert }\OperatorTok{({-}}\NormalTok{\_end }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c }\OperatorTok{\textless{}=} \OperatorTok{{-}}\NormalTok{x }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c}\OperatorTok{)}\NormalTok{ as H6.}
\NormalTok{            apply Z\_div\_le. nia. nia.}
           \KeywordTok{repeat}\NormalTok{ rewrite Zdiv\_opp\_opp in H6. assumption.}
        \OperatorTok{(}\NormalTok{* upper bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ assert }\OperatorTok{({-}}\NormalTok{x }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c }\OperatorTok{\textless{}=} \OperatorTok{{-}}\NormalTok{\_start }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c}\OperatorTok{)}\NormalTok{ as H6.}
\NormalTok{            apply Z\_div\_le. nia. nia.}
           \KeywordTok{repeat}\NormalTok{ rewrite Zdiv\_opp\_opp in H6. assumption.}
        \OperatorTok{(}\NormalTok{* divisibility *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ exists }\OperatorTok{({-}}\NormalTok{x\_minus\_start\_by\_step}\OperatorTok{)}\NormalTok{. rewrite H5. ring.}
    \OperatorTok{(}\NormalTok{* now step is negative *}\OperatorTok{)}
    \OperatorTok{{-}}\NormalTok{ destruct H2 as }\OperatorTok{[[}\NormalTok{H21 H22}\OperatorTok{]}\NormalTok{ H23}\OperatorTok{]}\NormalTok{.}
\NormalTok{      destruct H23 as }\OperatorTok{[}\NormalTok{x\_minus\_start\_by\_step H23}\OperatorTok{]}\NormalTok{.}
\NormalTok{      rewrite H1 in H23.}
      \OperatorTok{(}\NormalTok{* Same intermediate lemma as above *}\OperatorTok{)}
\NormalTok{      assert }\OperatorTok{(}\NormalTok{x }\OperatorTok{=}\NormalTok{ \_start }\OperatorTok{+} \OperatorTok{({-}}\NormalTok{ x\_minus\_start\_by\_step}\OperatorTok{)}\NormalTok{ * step\_by\_c * c}\OperatorTok{)} 
\NormalTok{        as H4 by nia.}
\NormalTok{      assert }\OperatorTok{(}\NormalTok{x }\OperatorTok{/}\NormalTok{ c }\OperatorTok{=}\NormalTok{ \_start }\OperatorTok{/}\NormalTok{ c }\OperatorTok{+} \OperatorTok{({-}}\NormalTok{ x\_minus\_start\_by\_step}\OperatorTok{)}\NormalTok{ * step\_by\_c}\OperatorTok{)}
\NormalTok{        as H5.}
\NormalTok{        rewrite H4. apply Z\_div\_plus\_full. assumption.}
      \OperatorTok{(}\NormalTok{* induction directly on step by c *}\OperatorTok{)}
\NormalTok{      induction step\_by\_c as }\OperatorTok{[} \OperatorTok{|}\NormalTok{ step\_by\_c }\OperatorTok{|}\NormalTok{ step\_by\_c }\OperatorTok{]}\NormalTok{.}
      \OperatorTok{(}\NormalTok{* step by c }\OperatorTok{=} \DecValTok{0}\NormalTok{ is invalid since step is negative *}\OperatorTok{)}
      \OperatorTok{+}\NormalTok{ discriminate.}
      \OperatorTok{(}\NormalTok{* step by c is positive *}\OperatorTok{)}
      \OperatorTok{+} \KeywordTok{repeat}\NormalTok{ split.}
        \OperatorTok{(}\NormalTok{* lower bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ assert }\OperatorTok{({-}}\NormalTok{\_start }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c }\OperatorTok{\textless{}=} \OperatorTok{{-}}\NormalTok{x }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c}\OperatorTok{)}\NormalTok{ as H6.}
\NormalTok{            apply Z\_div\_le. nia. nia.}
          \KeywordTok{repeat}\NormalTok{ rewrite Zdiv\_opp\_opp in H6. assumption.}
        \OperatorTok{(}\NormalTok{* upper bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ assert }\OperatorTok{({-}}\NormalTok{x }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c }\OperatorTok{\textless{}=} \OperatorTok{{-}}\NormalTok{\_end }\OperatorTok{/} \OperatorTok{{-}}\NormalTok{c}\OperatorTok{)}\NormalTok{ as H6.}
\NormalTok{            apply Z\_div\_le. nia. nia.}
          \KeywordTok{repeat}\NormalTok{ rewrite Zdiv\_opp\_opp in H6. assumption.}
        \OperatorTok{(}\NormalTok{* divisibility *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ exists }\OperatorTok{({-}}\NormalTok{x\_minus\_start\_by\_step}\OperatorTok{)}\NormalTok{. rewrite H5. ring.}
      \OperatorTok{(}\NormalTok{* step by c is negative *}\OperatorTok{)}
      \OperatorTok{+} \KeywordTok{repeat}\NormalTok{ split.}
        \OperatorTok{(}\NormalTok{* lower bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ apply Z\_div\_le. nia. assumption.}
        \OperatorTok{(}\NormalTok{* upper bound *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ apply Z\_div\_le. nia. assumption.}
        \OperatorTok{(}\NormalTok{* divisibility *}\OperatorTok{)}
        \OperatorTok{{-}{-}}\NormalTok{ exists x\_minus\_start\_by\_step. rewrite H5. ring.}
\NormalTok{Qed.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{Theorem interval\_mod :}\NormalTok{ forall x c }\OperatorTok{:}\NormalTok{ Z}\OperatorTok{,}\NormalTok{ forall In }\OperatorTok{:}\NormalTok{ Interval}\OperatorTok{,}
    \OperatorTok{(}\NormalTok{inInterval x In}\OperatorTok{)} \OperatorTok{/}\NormalTok{\textbackslash{} }\OperatorTok{((}\NormalTok{intervalStart In}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} \OperatorTok{=} \OperatorTok{((}\NormalTok{intervalEnd In}\OperatorTok{)} \OperatorTok{/}\NormalTok{ c}\OperatorTok{)} 
    \OperatorTok{/}\NormalTok{\textbackslash{} c }\OperatorTok{\textless{}\textgreater{}} \DecValTok{0} \OperatorTok{{-}\textgreater{}}
    \OperatorTok{(}\NormalTok{x mod c}\OperatorTok{)} \OperatorTok{=} \OperatorTok{((}\NormalTok{intervalStart In}\OperatorTok{)}\NormalTok{ mod c}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{x }\OperatorTok{{-}} \OperatorTok{(}\NormalTok{intervalStart In}\OperatorTok{))}\NormalTok{.}
\NormalTok{Proof.}
\NormalTok{    intros. apply interval\_div in H as H0.}
\NormalTok{    destruct H as }\OperatorTok{[}\NormalTok{H1 }\OperatorTok{[}\NormalTok{H2 H3}\OperatorTok{]]}\NormalTok{. destruct In.}
\NormalTok{    unfold intervalMin in H2. unfold intervalMax in H2.}
\NormalTok{    unfold inInterval in H1. unfold intervalMin in H0.}
\NormalTok{    unfold intervalMin. }\KeywordTok{repeat}\NormalTok{ rewrite Zmod\_eq\_full.}
\NormalTok{    rewrite H0. nia. assumption. assumption.}
\NormalTok{Qed.}
\end{Highlighting}
\end{Shaded}
